// Code generated by mockery v2.12.3. DO NOT EDIT.

package mocks

import (
	context "context"

	common "github.com/tidepool-org/tide-whisperer/common"

	mock "github.com/stretchr/testify/mock"

	mongo "github.com/tidepool-org/go-common/clients/mongo"

	schema "github.com/tidepool-org/tide-whisperer/schema"
)

// PatientDataRepository is an autogenerated mock type for the PatientDataRepository type
type PatientDataRepository struct {
	mock.Mock
}

// GetDataInDeviceData provides a mock function with given fields: ctx, traceID, userID, dates, excludeTypes
func (_m *PatientDataRepository) GetDataInDeviceData(ctx context.Context, traceID string, userID string, dates *common.Date, excludeTypes []string) (mongo.StorageIterator, error) {
	ret := _m.Called(ctx, traceID, userID, dates, excludeTypes)

	var r0 mongo.StorageIterator
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *common.Date, []string) mongo.StorageIterator); ok {
		r0 = rf(ctx, traceID, userID, dates, excludeTypes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(mongo.StorageIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, *common.Date, []string) error); ok {
		r1 = rf(ctx, traceID, userID, dates, excludeTypes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataRangeLegacy provides a mock function with given fields: ctx, traceID, userID
func (_m *PatientDataRepository) GetDataRangeLegacy(ctx context.Context, traceID string, userID string) (*common.Date, error) {
	ret := _m.Called(ctx, traceID, userID)

	var r0 *common.Date
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *common.Date); ok {
		r0 = rf(ctx, traceID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*common.Date)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, traceID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestBasalSecurityProfile provides a mock function with given fields: ctx, traceID, userID
func (_m *PatientDataRepository) GetLatestBasalSecurityProfile(ctx context.Context, traceID string, userID string) (*schema.DbProfile, error) {
	ret := _m.Called(ctx, traceID, userID)

	var r0 *schema.DbProfile
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *schema.DbProfile); ok {
		r0 = rf(ctx, traceID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.DbProfile)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, traceID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoopMode provides a mock function with given fields: ctx, traceID, userID, dates
func (_m *PatientDataRepository) GetLoopMode(ctx context.Context, traceID string, userID string, dates *common.Date) ([]schema.LoopModeEvent, error) {
	ret := _m.Called(ctx, traceID, userID, dates)

	var r0 []schema.LoopModeEvent
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *common.Date) []schema.LoopModeEvent); ok {
		r0 = rf(ctx, traceID, userID, dates)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]schema.LoopModeEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, *common.Date) error); ok {
		r1 = rf(ctx, traceID, userID, dates)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUploadData provides a mock function with given fields: ctx, traceID, uploadIds
func (_m *PatientDataRepository) GetUploadData(ctx context.Context, traceID string, uploadIds []string) (mongo.StorageIterator, error) {
	ret := _m.Called(ctx, traceID, uploadIds)

	var r0 mongo.StorageIterator
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) mongo.StorageIterator); ok {
		r0 = rf(ctx, traceID, uploadIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(mongo.StorageIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, traceID, uploadIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type NewPatientDataRepositoryT interface {
	mock.TestingT
	Cleanup(func())
}

// NewPatientDataRepository creates a new instance of PatientDataRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewPatientDataRepository(t NewPatientDataRepositoryT) *PatientDataRepository {
	mock := &PatientDataRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
